// ìŠ¤ë§ˆíŠ¸ ì§€íŒ¡ì´ ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œ - JavaScript Core Functions

// MQTT ì—°ê²° ë° ë©”ì‹œì§€ ì²˜ë¦¬
const MQTT_TOPIC_SUB = 'SC_pub';
let client;
let isConnected = false;

// ìŒì„± ì•Œë¦¼ ì œì–´ ë³€ìˆ˜
let lastSpeechTime = 0;
let lastSensorSpeech = 0;
const speechCooldown = 10000; // 10ì´ˆ ê°„ê²©

// ì•± ì´ˆê¸°í™” í•¨ìˆ˜
function initializeApp() {
    // DOM ìš”ì†Œë“¤ ì´ˆê¸°í™”
    connectionStatus = document.getElementById('connectionStatus');
    distance1 = document.getElementById('distance1');
    distance2 = document.getElementById('distance2');
    status1 = document.getElementById('status1');
    status2 = document.getElementById('status2');
    safetyStatus = document.getElementById('safetyStatus');
    fallStatus = document.getElementById('fallStatus');
    obstacleStatus = document.getElementById('obstacleStatus');
    lastUpdate = document.getElementById('lastUpdate');

    // MQTT ì—°ê²° ì„¤ì •
    const clientId = 'webClient_' + Math.random().toString(16).substr(2, 8);
    const isHttps = location.protocol === 'https:';
    const mqttUrl = isHttps ? 'wss://pubcode2.iptime.org:39002' : 'ws://pubcode2.iptime.org:39001';
    
    try {
        client = mqtt.connect(mqttUrl, {
            clientId: clientId,
            clean: true,
            keepalive: 30,
            connectTimeout: 15 * 1000,
            reconnectPeriod: 5000,
            protocolVersion: 4
        });
        setupMQTTEvents();
    } catch (error) {
        console.error('MQTT í´ë¼ì´ì–¸íŠ¸ ìƒì„± ì‹¤íŒ¨:', error);
        updateConnectionStatus(false, 'MQTT ì—°ê²° ì‹¤íŒ¨');
    }
}

// MQTT ë©”ì‹œì§€ ì²˜ë¦¬ í•¨ìˆ˜
function processMessage(data) {
    console.log('ì²˜ë¦¬ ì¤‘ì¸ ë©”ì‹œì§€:', data);
    
    // ë‚™ìƒ ê°ì§€ ì²´í¬
    if (data.includes('"event":"FALL"') || data === 'FALL') {
        handleFallDetection();
        return;
    }
    
    // JSON í˜•íƒœ ë°ì´í„° íŒŒì‹±
    try {
        const jsonData = JSON.parse(data);
        if (jsonData.event === 'FALL') {
            handleFallDetection();
            return;
        }
        if (jsonData.sensor1 !== undefined && jsonData.sensor2 !== undefined) {
            updateSensorDisplay(1, jsonData.sensor1);
            updateSensorDisplay(2, jsonData.sensor2);
            return;
        }
    } catch (e) {
        // JSONì´ ì•„ë‹Œ ê²½ìš° ë‹¤ë¥¸ íŒŒì‹± ë°©ë²• ì‹œë„
    }
    
    // ê±°ë¦¬ ë°ì´í„° íŒŒì‹±
    if (data.includes('Distance Alert!')) {
        handleDistanceAlert(data);
        parseDistanceData(data);
    } else if (data.includes('d1=') && data.includes('d2=')) {
        parseDistanceData(data);
    } else if (data.includes('ì„¼ì„œ1') && data.includes('ì„¼ì„œ2')) {
        parseKoreanDistanceData(data);
    }
}

// ìŒì„± ì•Œë¦¼ í•¨ìˆ˜ (Chrome ë¸Œë¼ìš°ì € í˜¸í™˜)
function speakMessage(message, priority = 'normal') {
    const currentTime = Date.now();
    
    if (priority === 'high' || currentTime - lastSpeechTime > speechCooldown) {
        if ('speechSynthesis' in window) {
            try {
                window.speechSynthesis.cancel();
                
                const utterance = new SpeechSynthesisUtterance(message);
                const voices = window.speechSynthesis.getVoices();
                const koreanVoice = voices.find(voice => 
                    voice.lang.includes('ko') || voice.lang.includes('KR')
                );
                
                if (koreanVoice) {
                    utterance.voice = koreanVoice;
                    utterance.lang = koreanVoice.lang;
                } else {
                    utterance.lang = 'ko-KR';
                }
                
                utterance.rate = 0.9;
                utterance.pitch = 1.0;
                utterance.volume = 1.0;
                
                window.speechSynthesis.speak(utterance);
                lastSpeechTime = currentTime;
                
            } catch (error) {
                console.error('ìŒì„± í•©ì„± ì˜¤ë¥˜:', error);
                showTextAlert(message);
            }
        } else {
            showTextAlert(message);
        }
    }
}

// ë‚™ìƒ ê°ì§€ ì²˜ë¦¬
function handleFallDetection() {
    fallStatus.textContent = 'ğŸš¨ ë‚™ìƒ ê°ì§€ë¨!';
    fallStatus.className = 'alert-message alert-fall';
    safetyStatus.textContent = 'ğŸš¨ ì‘ê¸‰ ìƒí™© ë°œìƒ!';
    safetyStatus.className = 'alert-message alert-fall';

    speakMessage('ê²½ê³ ! ë‚™ìƒì´ ê°ì§€ë˜ì—ˆìŠµë‹ˆë‹¤. ì‘ê¸‰ ìƒí™©ì…ë‹ˆë‹¤.', 'high');

    setTimeout(() => {
        fallStatus.textContent = 'ì •ìƒ ìƒíƒœ';
        fallStatus.className = 'alert-message alert-normal';
        updateSafetyStatus();
        speakMessage('ë‚™ìƒ ê²½ê³ ê°€ í•´ì œë˜ì—ˆìŠµë‹ˆë‹¤.');
    }, 5000);
}

// ì„¼ì„œ í‘œì‹œ ì—…ë°ì´íŠ¸
function updateSensorDisplay(sensorNum, distance) {
    console.log(`ì„¼ì„œ${sensorNum} ì—…ë°ì´íŠ¸: ${distance}cm`);
    
    if (sensorNum === 1) {
        distance1.textContent = distance + ' cm';
        updateSensorStatus(status1, distance);
    } else if (sensorNum === 2) {
        distance2.textContent = distance + ' cm';
        updateSensorStatus(status2, distance);
    }

    // ì¥ì• ë¬¼ ê°ì§€ ì²´í¬
    if (distance < 20) {
        triggerObstacleAlert(sensorNum, distance);
    }
}

// ì¥ì• ë¬¼ ê²½ê³  íŠ¸ë¦¬ê±°
function triggerObstacleAlert(sensorNum, distance) {
    obstacleStatus.textContent = `âš ï¸ ì„¼ì„œ${sensorNum}ì—ì„œ ì¥ì• ë¬¼ ê°ì§€! (${distance}cm)`;
    obstacleStatus.className = 'alert-message alert-obstacle';
    safetyStatus.textContent = 'âš ï¸ ì£¼ì˜ í•„ìš”';
    safetyStatus.className = 'alert-message alert-obstacle';

    speakMessage(`ì£¼ì˜! ì„¼ì„œ ${sensorNum}ì—ì„œ ${distance}ì„¼í‹°ë¯¸í„° ê±°ë¦¬ì— ì¥ì• ë¬¼ì´ ê°ì§€ë˜ì—ˆìŠµë‹ˆë‹¤.`, 'high');

    setTimeout(() => {
        if (!obstacleStatus.className.includes('alert-obstacle')) return;
        obstacleStatus.textContent = 'ê²½ë¡œ ì•ˆì „';
        obstacleStatus.className = 'alert-message alert-normal';
        updateSafetyStatus();
        speakMessage('ì¥ì• ë¬¼ì´ í•´ì œë˜ì—ˆìŠµë‹ˆë‹¤. ê²½ë¡œê°€ ì•ˆì „í•©ë‹ˆë‹¤.');
    }, 3000);
}
